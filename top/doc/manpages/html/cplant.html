  <!-- manual page source format generated by PolyglotMan v3.0.9, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>CPLANT(3) manual page</TITLE>
</HEAD>
<BODY bgcolor=white>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">Name</A></H2>
    <BR>
 <P>
  Cplant* functions - access to Cplant runtime environment for a parallel
applicati
on 
<H2><A NAME="sect1" HREF="#toc1">Synopsis</A></H2>
    <BR>
 <P>
  <B>#include &lt;cplant.h&gt;</B> 
<H2><A NAME="sect2" HREF="#toc2">Description</A></H2>
    <BR>
 <P>
  Cplant applications are automatically linked with a library of functions
that provide information about the current runtime environment of the application
and of the cluster as a whole.  Other functions permit a Cplant application
to spawn a new application, synchronize with it, and obtain the node ID/process
ID map required to communicate with it.  The functions are summarized here.
 See the individual man page for each function for more detail. 
<H2><A NAME="sect3" HREF="#toc3">See Also</A></H2>

   <BR>
 <P>
  <B>bebopd</B> <B>yod</B> <B>yod2</B> 
<H2><A NAME="sect4" HREF="#toc4">Bugs</A></H2>
    <BR>
 <P>
  The node ID map and process ID map returned by <B>CplantJobNidMap</B>  and
<B>CplantJobPidMap</B>  respectively are not necessarily in process rank order,
they are in physical node number order.  The functions that query the bebopd
to obtain information about other jobs or about the PBS queues are not
fully tested. In addition they appear to allocate much more memory than
they need to hold the returned information. 
<H2><A NAME="sect5" HREF="#toc5">List of Functions</A></H2>
<P>
  The following
functions return information about the calling application.  They are satisfied
locally without sending a request to a remote node.  <P>

<DL>

<DT><I>CplantMyNid</I> </DT>
<DD>    returns
<P>
your physical node ID <P>
 </DD>

<DT><I>CplantMyPpid</I> </DT>
<DD>    returns your portals process ID
<P>
 </DD>

<DT><I>CplantMyRank</I> </DT>
<DD>    returns your rank in the application, zero based <P>
 </DD>

<DT><I>CplantMyPid</I>
</DT>
<DD>    returns your the Linux system pid (same result as <B>getpid()</B>) <P>
 </DD>

<DT><I>CplantMySize</I>
</DT>
<DD>    returns the number of processes in your parallel application <P>
 </DD>

<DT><I>CplantMyJobId</I>
</DT>
<DD>    returns your Cplant job ID (a Cplant job is a single Cplant parallel
application) <P>
 </DD>

<DT><I>CplantMyPBSid</I> </DT>
<DD>    returns your PBS job ID (a PBS job is a
job script that may start many Cplant job
s) <P>
 </DD>

<DT><I>CplantMyNidMap</I> </DT>
<DD>    returns
<P>
the physical Node ID map for all processes in your parallel application
<P>
 </DD>

<DT><I>CplantMyPidMap</I> </DT>
<DD>    returns the portals process ID map for all processes
in your parallel application </DD>
</DL>
<P>
  The following functions return information
about other Cplant jobs, or about the PBS queues.  These queries are satisfied
by sending a request for information to the bebopd.  <P>

<DL>

<DT><I>CplantJobSize</I> </DT>
<DD>    returns
<P>
the number of processes in another parallel application <P>
 </DD>

<DT><I>CplantJobNidMap</I>
</DT>
<DD>    returns the physical node ID map for another parallel application -
warning, it's not in process rank order <P>
 </DD>

<DT><I>CplantJobPidMap</I> </DT>
<DD>    returns the
portals process ID map for another parallel application - warning, it
's
<P>
not in process rank order <P>
 </DD>

<DT><I>CplantJobStatus</I> </DT>
<DD>    returns an array of status
<P>
structures describing another parallel application <P>
 </DD>

<DT><I>CplantPBSQueue</I> </DT>
<DD>   
returns the status of a PBS queue, as given by the <B>qmgr -c "l q &lt;queue-name&gt;"\
fP
<P>
command </B><P>
 </DD>

<DT><I>CplantPBSqstat</I> </DT>
<DD>    returns the information given by the PBS command
<P>
<B>qstat -a</B> <P>
 </DD>

<DT><I>CplantPBSqueues</I> </DT>
<DD>    returns the information given by the PBS command
<B>qstat -q</B>  <P>
 </DD>

<DT><I>CplantPBSserver</I> </DT>
<DD>    returns the information given by the PBS
command <B>qmgr -c "l s"</B>  </DD>
</DL>
<P>
  The following functions may be used to spawn new
applications and interact with t
hem. They send requests to a special version
of <B>yod</B> (called <B>yod2</B>) which is
 capable of managing a <I>family</I> of applications.
 A <I>family</I> refers all the jobs s
tarted by the original Cplant application
and it's descendants.  <P>

<DL>

<DT><I>CplantSpawnJob</I> </DT>
<DD>    A request to spawn a new application.
 A handle is returned.  The handle is a  pointer to a structure containing
status information for the new application.  A collective version of the
call (<B>CplantSpawnJobGrp</B>) is available, wherein node 0 sends the request
to <B>yod2</B>, and broadcasts the results to the other processes. <P>
 </DD>

<DT><I>CplantFamilyStatus</I>
</DT>
<DD>    A request for the latest status information for a job in my family.
A collective version of the call (<B>CplantFamilyStatusGrp</B>) is available,
wher
ein node 0 sends the request to <B>yod2</B>, and broadcasts the results to
the other processes. <P>
 <P>
 </DD>

<DT><I>CplantFamilyMap</I> </DT>
<DD>    This call returns the physical
node ID map and the portals process ID map for a job in my family. A collective
version of the call (<B>CplantFamilyMapGrp</B>) is available, wherein node 0 sends
the request to <B>yod2</B>, and broadcasts the results to the other processes.
<P>
 </DD>

<DT><I>CplantFamilyTermination</I> </DT>
<DD>    This call returns any or all of the following
information about  a job in my family: whether or not each process has
terminated, the exit code for each process, the terminating signal for
each process, and the terminator for each process (i.e. terminated by owner
or terminated by system administrator or not terminated by an outside action).
A collective version of the call (<B>CplantFamilyTerminationGrp</B>) is available,

 wherein node 0 sends the request to <B>yod2</B>, and broadcasts the results to
the other processes. <P>
 </DD>

<DT><I>CplantMyParent</I> </DT>
<DD>    This call returns the handle for
the application that spawned me, or NULL if I was not spawned by another
Cplant application. A collective version of the call (<B>CplantMyParentGrp</B>)
is available, wherein node 0 sends the request to <B>yod2</B>, and broadcasts
the results to the other processes. <P>
 </DD>

<DT><I>CplantMySelf</I> </DT>
<DD>    This call returns
the handle for my application, in the event I may want to send it to another
application in my family that wishes to query <B>yod2</B> about me. A collective
version of the call (<B>CplantMySelfGrp</B>) is available, wherein node 0 sends
the request to <B>yod2</B>, and broadcasts the results to the other processes.
<P>
 </DD>

<DT><I>CplantInterjobBarrier</I> </DT>
<DD>    This call begins a barrier between my job and
one other in my family.  It returns a status indicating that either the
barrier is in progress, or the barrier is completed. A collective version
of the call (<B>CplantInterjobBarrierGrp</B>) is available, wherein node 0 sends
the request to <B>yod2</B>, and broadcasts the results to the other processes.
<P>
 </DD>

<DT><I>CplantBarrierStatus</I> </DT>
<DD>    This call sends a query to <B>yod2</B> to find out if
an inter-job barrier has completed.  It returns a status indicating that
the barrier is still in progress or that it has completed. A collective
version of the call (<B>CplantBarrierStatusGrp</B>) is available, whe
rein node
0 sends the request to <B>yod2</B>, and broadcasts the results to the other processes.
<P>
 </DD>

<DT><I>CplantSignalJob</I> </DT>
<DD>    This call sends a request to <B>yod2</B> to send a signal
to a job in my family. <P>
 </DD>

<DT><I>CplantNodesRemaining</I> </DT>
<DD>    For PBS jobs only, this
call sends a request to <B>yod2</B> to reply with the diff
erence between the
number of nodes allocated me by PBS, and the number of nodes in use b
y
<B>yod2</B>.  Note that if your PBS script started other <B>yod</B> or <B>yod2</B> p
rocesses
this difference is less than the number of nodes you have remaining to
use.  <P>
 </DD>

<DT><I>CplantInitCollective</I> </DT>
<DD>    Applications that wish to use the <B>*Grp</B> collective
functions, must first initialize the server library group communication
function.  Each process in the application must call this, and it contains
a barrier. <P>
 </DD>

<DT><I>CplantDoneCollective</I> </DT>
<DD>    This call frees the structures required
for server library group communication. </DD>
</DL>
<P>
 
<H2><A NAME="sect6" HREF="#toc6">List of Structures and Defined
Values</A></H2>
<P>
  The handle returned by job spawn/status functions has the following
structure:  CRtypedef struct _jobFamilyInfo{  <BR>
int job_id;          /* Cplant job id */ <BR>
int yodHandle;       /* a handle for requests to yod */ <BR>
int status;          /* bit map of JOB_* values */ <BR>
int nprocs;          /* number of processes in the application */ <BR>
int error;           /* normally 0, non-0 if an error occured */ <BR>
void *callerHandle;  /* caller can use this, we don't */ <BR>
}jobFamilyInfo;   The status bits in the status field have the following
values:  CR#define JOB_NODE_REQUEST_BUILT  ( 1 &lt;&lt; 0)  <BR>
#define JOB_PCT_LIST_ALLOCATED  ( 1 &lt;&lt; 1)  <BR>
#define JOB_REQUESTED_TO_LOAD   ( 1 &lt;&lt; 2)  <BR>
#define JOB_GOT_OK_TO_LOAD      ( 1 &lt;&lt; 3)  <BR>
#define JOB_APP_STARTED         ( 1 &lt;&lt; 4)  <BR>
#define JOB_APP_FINISHED        ( 1 &lt;&lt; 5)  <BR>
#define JOB_APP_MASS_MURDER     ( 1 &lt;&lt; 30)    The values for the terminator
of a job, provided by the <B>CplantFamilyTerminatio
n</B> query, 
are:  CR#define
PCT_TERMINATOR_UNSET (0)   /* job hasn't terminated */  <BR>
#define PCT_NO_TERMINATOR    (1)   /* job was not terminated from the outside
*/  <BR>
#define PCT_JOB_OWNER        (2)   /* job was terminated because owner
interrupted it */  <BR>
#define PCT_ADMINISTRATOR    (3)   /* job was terminated because sys admin
interrupted it */    The values for status of an inter-job barrier are:
 CR#define SYNC_COMPLETED   1   <BR>
#define SYNC_IN_PROGRESS 0  <BR>
#define SYNC_ERROR      (-1)   <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Synopsis</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Description</A></LI>
<LI><A NAME="toc3" HREF="#sect3">See Also</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Bugs</A></LI>
<LI><A NAME="toc5" HREF="#sect5">List of Functions</A></LI>
<LI><A NAME="toc6" HREF="#sect6">List of Structures and Defined Values</A></LI>
</UL>
</BODY></HTML>
