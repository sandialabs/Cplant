  <!-- manual page source format generated by PolyglotMan v3.0.9, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>MYPARENT(3) manual page</TITLE>
</HEAD>
<BODY bgcolor=white>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">Name</A></H2>
    <BR>
 <P>
  CplantMyParent, CplantMyParentGrp, CplantMySelf, CplantMySelfGrp 
<H2><A NAME="sect1" HREF="#toc1">Synopsis</A></H2>

   <BR>
 <P>
  <B>#include &lt;cplant.h&gt;</B>  <B>jobFamilyInfo *CplantMyParent(void)</B>  <B>jobFamilyInfo
*CplantMySelf(void)</B>  <B>jobFamilyInfo *CplantMyParentGrp(int </B><I>nMembers</I><B>, int
*</B><I>rankList
</I><B>, int 
</B><I>tmout</I><B>)</B>  <B>jobFamilyInfo *CplantMySelfGrp(int </B><I>nMembers</I><B>, int
*</B><I>rankList
P<B>, int 
P<I>tmout</I></B></I><B>)</B>  
<H2><A NAME="sect2" HREF="#toc2">Description</A></H2>
    <BR>
 <P>
  The function <B>CplantMyParent</B> returns the job handle associated with 
the Cplant job that spawned the calling job. This handle is required for
querying <B>yod2</B> for status, node map, and termination information.  If the
calling job was not created by a call to CplantSpawnJob, then a NULL pointer
is returned.  The function <B>CplantMySelf</B> returns the job handle associated
with my own application.  It is unlikely an application would ever need
to query <B>yod2</B> about itself, but perhaps a job would want to broadcast this
information to other jobs in it's family.  The functions <B>CplantMyParentGrp</B>
and <B>CplantMySelfGrp</B> are  collective calls. Every process that participates
in the call make the call with the same list of participants. <I>nMembers</I> is
the number of processes participating in the call, <I>rankList</I> is the list
of participating process ranks, and <I>tmout</I> is the number of seconds to wait
before judging a collective operation among the pariticpants to be a failure.
 In our implementation of this call, the first process in the <I>rankList</I>
makes the request to <B>yod2</B> and broadcasts the results to the others.  If
<I>nMembers</I> is zero, or <I>rankList</I> is NULL, then this is taken to mean that
all processes in the application are participating. 
<H2><A NAME="sect3" HREF="#toc3">Return Value</A></H2>
    <BR>
 <P>
  Both functions return a NULL pointer on error, and a pointer to a <B>jobFamilyInfo</B>
structure on success.  The structure may be freed by the caller when it
is no longer needed.  CRtypedef struct _jobFamilyInfo{     <BR>
int job_id;      /* Cplant job id */     <BR>
int yodHandle;   /* yod2 needs this */   <BR>
int status;      /* bit map of JOB_* values */     <BR>
int nprocs ;     /* number of processes*/ <BR>
int error;       /* normally 0, -1 if an error occurred */ <BR>
void *callerHandle;  /* caller can use this, we don't */     <BR>
}<B>jobFamilyInfo</B>;       CR#define JOB_NODE_REQUEST_BUILT  ( 1 &lt;&lt; 0)  <BR>
#define JOB_PCT_LIST_ALLOCATED  ( 1 &lt;&lt; 1)  <BR>
#define JOB_REQUESTED_TO_LOAD   ( 1 &lt;&lt; 2)  <BR>
#define JOB_GOT_OK_TO_LOAD      ( 1 &lt;&lt; 3)  <BR>
#define JOB_APP_STARTED         ( 1 &lt;&lt; 4)  <BR>
#define JOB_APP_FINISHED        ( 1 &lt;&lt; 5)  <BR>
#define JOB_APP_MASS_MURDER     ( 1 &lt;&lt; 30)   
<H2><A NAME="sect4" HREF="#toc4">See Also</A></H2>
    <BR>
 <P>
  <B>yod2</B> <B>CplantFamilyStatus</B> <B>CplantFamilyTermination</B> <B>CplantFamilyMap</B> <B>CplantSpawnJob</B>
<P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Synopsis</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Description</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Return Value</A></LI>
<LI><A NAME="toc4" HREF="#sect4">See Also</A></LI>
</UL>
</BODY></HTML>
