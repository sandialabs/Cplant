/*************************************************************************
Cplant Release Version 2.0.1.10
Release Date: Nov 5, 2002 
#############################################################################
#
#     This Cplant(TM) source code is the property of Sandia National
#     Laboratories.
#
#     This Cplant(TM) source code is copyrighted by Sandia National
#     Laboratories.
#
#     The redistribution of this Cplant(TM) source code is subject to the
#     terms of the GNU Lesser General Public License
#     (see cit/LGPL or http://www.gnu.org/licenses/lgpl.html)
#
#     Cplant(TM) Copyright 1998, 1999, 2000, 2001, 2002 Sandia Corporation. 
#     Under the terms of Contract DE-AC04-94AL85000, there is a non-exclusive
#     license for use of this work by or on behalf of the US Government.
#     Export of this program may require a license from the United States
#     Government.
#
#############################################################################
**************************************************************************/
/*
 * $Id: wrap.c,v 1.5 2001/05/24 23:20:28 rbbrigh Exp $
 *
 * wrap.c
 *
 * User-level wrappers that dispatch across the protection boundaries
 * This file was generated by idl
 *
 * Assumes the handle encodes the network number in the second 16 bit word
 */
#include <stdio.h>
#include <p30.h>
#include <p30/arg-blocks.h>
#include <p30/internal.h>
#include <p30/lib-dispatch.h>


int PtlGetId(
	ptl_handle_ni_t	handle_in,
	ptl_process_id_t	*	id_out,
	ptl_id_t		*	gsize_out
)
{
	PtlGetId_in		args;
	PtlGetId_out	ret;
	nal_t			*nal;

	if( !ptl_init ) {
		fprintf( stderr, "PtlGetId: Not initialized\n" );
		return PTL_NOINIT;
	}

	/*
	 * Copy arguments into the argument block to
	 * hand to the forwarding object
	 */
	args.handle_in	= handle_in;

	nal = ptl_interfaces[(handle_in >> 16) & 0xF];
	if( !nal )
		return PTL_NOINIT;

	nal->forward(
		nal,
		PTL_GETID,
		&args,	sizeof(args),
		&ret,	sizeof(ret)
	);

	/*
	 * Copy the results into the return block
	 */
	if( id_out )
		*id_out = ret.id_out;
	if( gsize_out )
		*gsize_out = ret.gsize_out;



	/* Return the result */
	return ret.rc;
}



int PtlTransId(
	ptl_handle_ni_t	handle_in,
	ptl_process_id_t	id_in,
	ptl_process_id_t	*	id_out
)
{
	PtlTransId_in		args;
	PtlTransId_out	ret;
	nal_t			*nal;

	if( !ptl_init ) {
		fprintf( stderr, "PtlTransId: Not initialized\n" );
		return PTL_NOINIT;
	}

	/*
	 * Copy arguments into the argument block to
	 * hand to the forwarding object
	 */
	args.handle_in	= handle_in;
	args.id_in	= id_in;



	nal = ptl_interfaces[(handle_in >> 16) & 0xF];
	if( !nal )
		return PTL_NOINIT;

	nal->forward(
		nal,
		PTL_TRANSID,
		&args,	sizeof(args),
		&ret,	sizeof(ret)
	);

	/*
	 * Copy the results into the return block
	 */
	if( id_out )
		*id_out = ret.id_out;



	/* Return the result */
	return ret.rc;
}



int PtlNIStatus(
	ptl_handle_ni_t	interface_in,
	ptl_sr_index_t	register_in,
	ptl_sr_value_t		*	status_out
)
{
	PtlNIStatus_in		args;
	PtlNIStatus_out	ret;
	nal_t			*nal;

	if( !ptl_init ) {
		fprintf( stderr, "PtlNIStatus: Not initialized\n" );
		return PTL_NOINIT;
	}

	/*
	 * Copy arguments into the argument block to
	 * hand to the forwarding object
	 */
	args.interface_in	= interface_in;
	args.register_in	= register_in;



	nal = ptl_interfaces[(interface_in >> 16) & 0xF];
	if( !nal )
		return PTL_NOINIT;

	nal->forward(
		nal,
		PTL_NISTATUS,
		&args,	sizeof(args),
		&ret,	sizeof(ret)
	);

	/*
	 * Copy the results into the return block
	 */
	if( status_out )
		*status_out = ret.status_out;



	/* Return the result */
	return ret.rc;
}



int PtlNIDist(
	ptl_handle_ni_t	interface_in,
	ptl_process_id_t	process_in,
	unsigned long		*	distance_out
)
{
	PtlNIDist_in		args;
	PtlNIDist_out	ret;
	nal_t			*nal;

	if( !ptl_init ) {
		fprintf( stderr, "PtlNIDist: Not initialized\n" );
		return PTL_NOINIT;
	}

	if ( !distance_out ) {
	    return PTL_SEGV;
	}

	/*
	 * Copy arguments into the argument block to
	 * hand to the forwarding object
	 */
	args.interface_in	= interface_in;
	args.process_in	= process_in;

	nal = ptl_interfaces[(interface_in >> 16) & 0xF];
	if( !nal )
		return PTL_INV_NI;

	nal->forward(
		nal,
		PTL_NIDIST,
		&args,	sizeof(args),
		&ret,	sizeof(ret)
	);

	/*
	 * Copy the results into the return block
	 */
	if( distance_out )
		*distance_out = ret.distance_out;



	/* Return the result */
	return ret.rc;
}



unsigned int PtlNIDebug(
	ptl_handle_ni_t	ni,
	unsigned int	mask_in
)
{
	PtlNIDebug_in		args;
	PtlNIDebug_out	ret;
	nal_t			*nal;

	if( !ptl_init ) {
		fprintf( stderr, "PtlNIDebug: Not initialized\n" );
		return PTL_NOINIT;
	}

	/*
	 * Copy arguments into the argument block to
	 * hand to the forwarding object
	 */
	args.mask_in	= mask_in;



	nal = ptl_interfaces[(ni >> 16) & 0xF];
	if( !nal )
		return PTL_NOINIT;

	nal->forward(
		nal,
		PTL_NIDEBUG,
		&args,	sizeof(args),
		&ret,	sizeof(ret)
	);

	/*
	 * Copy the results into the return block
	 */



	/* Return the result */
	return ret.rc;
}



int PtlMEAttach(
	ptl_handle_ni_t	interface_in,
	ptl_pt_index_t	index_in,
	ptl_process_id_t	match_id_in,
	ptl_match_bits_t	match_bits_in,
	ptl_match_bits_t	ignore_bits_in,
	ptl_unlink_t	unlink_in,
	ptl_handle_me_t		*	handle_out
)
{
	PtlMEAttach_in		args;
	PtlMEAttach_out	ret;
	nal_t			*nal;

	if( !ptl_init ) {
		fprintf( stderr, "PtlMEAttach: Not initialized\n" );
		return PTL_NOINIT;
	}

	/*
	 * Copy arguments into the argument block to
	 * hand to the forwarding object
	 */
	args.interface_in	= interface_in;
	args.index_in	= index_in;
	args.match_id_in	= match_id_in;
	args.match_bits_in	= match_bits_in;
	args.ignore_bits_in	= ignore_bits_in;
	args.unlink_in	= unlink_in;



	nal = ptl_interfaces[(interface_in >> 16) & 0xF];
	if( !nal )
		return PTL_NOINIT;

	nal->forward(
		nal,
		PTL_MEATTACH,
		&args,	sizeof(args),
		&ret,	sizeof(ret)
	);

	/*
	 * Copy the results into the return block
	 */
	if( handle_out )
		*handle_out = ret.handle_out;



	/* Return the result */
	return ret.rc;
}



int PtlMEInsert(
	ptl_handle_me_t	current_in,
	ptl_process_id_t	match_id_in,
	ptl_match_bits_t	match_bits_in,
	ptl_match_bits_t	ignore_bits_in,
	ptl_unlink_t	unlink_in,
	ptl_ins_pos_t	position_in,
	ptl_handle_me_t		*	handle_out
)
{
	PtlMEInsert_in		args;
	PtlMEInsert_out	ret;
	nal_t			*nal;

	if( !ptl_init ) {
		fprintf( stderr, "PtlMEInsert: Not initialized\n" );
		return PTL_NOINIT;
	}

	/*
	 * Copy arguments into the argument block to
	 * hand to the forwarding object
	 */
	args.current_in	= current_in;
	args.match_id_in	= match_id_in;
	args.match_bits_in	= match_bits_in;
	args.ignore_bits_in	= ignore_bits_in;
	args.unlink_in	= unlink_in;
	args.position_in	= position_in;



	nal = ptl_interfaces[(current_in >> 16) & 0xF];
	if( !nal )
		return PTL_NOINIT;

	nal->forward(
		nal,
		PTL_MEINSERT,
		&args,	sizeof(args),
		&ret,	sizeof(ret)
	);

	/*
	 * Copy the results into the return block
	 */
	if( handle_out )
		*handle_out = ret.handle_out;



	/* Return the result */
	return ret.rc;
}



int PtlMEUnlink(
	ptl_handle_me_t	current_in
)
{
	PtlMEUnlink_in		args;
	PtlMEUnlink_out	ret;
	nal_t			*nal;

	if( !ptl_init ) {
		fprintf( stderr, "PtlMEUnlink: Not initialized\n" );
		return PTL_NOINIT;
	}

	/*
	 * Copy arguments into the argument block to
	 * hand to the forwarding object
	 */
	args.current_in	= current_in;



	nal = ptl_interfaces[(current_in >> 16) & 0xF];
	if( !nal )
		return PTL_NOINIT;

	nal->forward(
		nal,
		PTL_MEUNLINK,
		&args,	sizeof(args),
		&ret,	sizeof(ret)
	);

	/*
	 * Copy the results into the return block
	 */



	/* Return the result */
	return ret.rc;
}



int PtlTblDump(
	ptl_handle_ni_t	ni,
	int	index_in
)
{
	PtlTblDump_in		args;
	PtlTblDump_out	ret;
	nal_t			*nal;

	if( !ptl_init ) {
		fprintf( stderr, "PtlTblDump: Not initialized\n" );
		return PTL_NOINIT;
	}

	/*
	 * Copy arguments into the argument block to
	 * hand to the forwarding object
	 */
	args.index_in	= index_in;



	nal = ptl_interfaces[(ni >> 16) & 0xF];
	if( !nal )
		return PTL_NOINIT;

	nal->forward(
		nal,
		PTL_TBLDUMP,
		&args,	sizeof(args),
		&ret,	sizeof(ret)
	);

	/*
	 * Copy the results into the return block
	 */



	/* Return the result */
	return ret.rc;
}



int PtlMEDump(
	ptl_handle_me_t	current_in
)
{
	PtlMEDump_in		args;
	PtlMEDump_out	ret;
	nal_t			*nal;

	if( !ptl_init ) {
		fprintf( stderr, "PtlMEDump: Not initialized\n" );
		return PTL_NOINIT;
	}

	/*
	 * Copy arguments into the argument block to
	 * hand to the forwarding object
	 */
	args.current_in	= current_in;



	nal = ptl_interfaces[(current_in >> 16) & 0xF];
	if( !nal )
		return PTL_NOINIT;

	nal->forward(
		nal,
		PTL_MEDUMP,
		&args,	sizeof(args),
		&ret,	sizeof(ret)
	);

	/*
	 * Copy the results into the return block
	 */



	/* Return the result */
	return ret.rc;
}



int PtlMDAttach_internal(
	ptl_handle_me_t	current_in,
	ptl_md_t	md_in,
	ptl_unlink_t	unlink_in,
	ptl_handle_md_t		*	handle_out
)
{
	PtlMDAttach_internal_in		args;
	PtlMDAttach_internal_out	ret;
	nal_t			*nal;

	if( !ptl_init ) {
		fprintf( stderr, "PtlMDAttach_internal: Not initialized\n" );
		return PTL_NOINIT;
	}

	/*
	 * Copy arguments into the argument block to
	 * hand to the forwarding object
	 */
	args.current_in	= current_in;
	args.md_in	= md_in;
	args.unlink_in	= unlink_in;



	nal = ptl_interfaces[(current_in >> 16) & 0xF];
	if( !nal )
		return PTL_NOINIT;

	nal->forward(
		nal,
		PTL_MDATTACH,
		&args,	sizeof(args),
		&ret,	sizeof(ret)
	);

	/*
	 * Copy the results into the return block
	 */
	if( handle_out )
		*handle_out = ret.handle_out;



	/* Return the result */
	return ret.rc;
}



int PtlMDInsert_internal(
	ptl_handle_md_t	current_in,
	ptl_md_t	md_in,
	ptl_unlink_t	unlink_in,
	ptl_ins_pos_t	position_in,
	ptl_handle_md_t		*	handle_out
)
{
	PtlMDInsert_internal_in		args;
	PtlMDInsert_internal_out	ret;
	nal_t			*nal;

	if( !ptl_init ) {
		fprintf( stderr, "PtlMDInsert_internal: Not initialized\n" );
		return PTL_NOINIT;
	}

	/*
	 * Copy arguments into the argument block to
	 * hand to the forwarding object
	 */
	args.current_in	= current_in;
	args.md_in	= md_in;
	args.unlink_in	= unlink_in;
	args.position_in	= position_in;



	nal = ptl_interfaces[(current_in >> 16) & 0xF];
	if( !nal )
		return PTL_NOINIT;

	nal->forward(
		nal,
		PTL_MDINSERT,
		&args,	sizeof(args),
		&ret,	sizeof(ret)
	);

	/*
	 * Copy the results into the return block
	 */
	if( handle_out )
		*handle_out = ret.handle_out;



	/* Return the result */
	return ret.rc;
}



int PtlMDBind_internal(
	ptl_handle_ni_t	ni_in,
	ptl_md_t	md_in,
	ptl_handle_md_t		*	handle_out
)
{
	PtlMDBind_internal_in		args;
	PtlMDBind_internal_out	ret;
	nal_t			*nal;

	if( !ptl_init ) {
		fprintf( stderr, "PtlMDBind_internal: Not initialized\n" );
		return PTL_NOINIT;
	}

	/*
	 * Copy arguments into the argument block to
	 * hand to the forwarding object
	 */
	args.ni_in	= ni_in;
	args.md_in	= md_in;



	nal = ptl_interfaces[(ni_in >> 16) & 0xF];
	if( !nal )
		return PTL_NOINIT;

	nal->forward(
		nal,
		PTL_MDBIND,
		&args,	sizeof(args),
		&ret,	sizeof(ret)
	);

	/*
	 * Copy the results into the return block
	 */
	if( handle_out )
		*handle_out = ret.handle_out;



	/* Return the result */
	return ret.rc;
}



int PtlMDUpdate_internal(
	ptl_handle_md_t	md_in,
	ptl_md_t		*	old_inout,
	ptl_md_t		*	new_inout,
	ptl_handle_eq_t	testq_in,
	ptl_seq_t	sequence_in
)
{
	PtlMDUpdate_internal_in		args;
	PtlMDUpdate_internal_out	ret;
	nal_t			*nal;

	if( !ptl_init ) {
		fprintf( stderr, "PtlMDUpdate_internal: Not initialized\n" );
		return PTL_NOINIT;
	}

	/*
	 * Copy arguments into the argument block to
	 * hand to the forwarding object
	 */
	args.md_in	= md_in;
	args.testq_in	= testq_in;
	args.sequence_in	= sequence_in;

	if( old_inout ) {
		args.old_inout	= *old_inout;
		args.old_inout_valid = 1;
	} else
		args.old_inout_valid = 0;

	if( new_inout ) {
		args.new_inout	= *new_inout;
		args.new_inout_valid = 1;
	} else
		args.new_inout_valid = 0;



	nal = ptl_interfaces[(md_in >> 16) & 0xF];
	if( !nal )
		return PTL_NOINIT;

	nal->forward(
		nal,
		PTL_MDUPDATE,
		&args,	sizeof(args),
		&ret,	sizeof(ret)
	);

	/*
	 * Copy the results into the return block
	 */

	if( old_inout )
		*old_inout = ret.old_inout;

	/* Return the result */
	return ret.rc;
}



int PtlMDUnlink_internal(
	ptl_handle_md_t	md_in,
	ptl_md_t		*	status_out
)
{
	PtlMDUnlink_internal_in		args;
	PtlMDUnlink_internal_out	ret;
	nal_t			*nal;

	if( !ptl_init ) {
		fprintf( stderr, "PtlMDUnlink_internal: Not initialized\n" );
		return PTL_NOINIT;
	}

	/*
	 * Copy arguments into the argument block to
	 * hand to the forwarding object
	 */
	args.md_in	= md_in;



	nal = ptl_interfaces[(md_in >> 16) & 0xF];
	if( !nal )
		return PTL_NOINIT;

	nal->forward(
		nal,
		PTL_MDUNLINK,
		&args,	sizeof(args),
		&ret,	sizeof(ret)
	);

	/*
	 * Copy the results into the return block
	 */
	if( status_out )
		*status_out = ret.status_out;



	/* Return the result */
	return ret.rc;
}



int PtlEQAlloc_internal(
	ptl_handle_ni_t	ni_in,
	ptl_size_t	count_in,
	void			*	base_in,
	int	len_in,
	ptl_handle_eq_t		*	handle_out
)
{
	PtlEQAlloc_internal_in		args;
	PtlEQAlloc_internal_out	ret;
	nal_t			*nal;

	if( !ptl_init ) {
		fprintf( stderr, "PtlEQAlloc_internal: Not initialized\n" );
		return PTL_NOINIT;
	}

	/*
	 * Copy arguments into the argument block to
	 * hand to the forwarding object
	 */
	args.ni_in	= ni_in;
	args.count_in	= count_in;
	args.base_in	= base_in;
	args.len_in	= len_in;



	nal = ptl_interfaces[(ni_in >> 16) & 0xF];
	if( !nal )
		return PTL_NOINIT;

	nal->forward(
		nal,
		PTL_EQALLOC,
		&args,	sizeof(args),
		&ret,	sizeof(ret)
	);

	/*
	 * Copy the results into the return block
	 */
	if( handle_out )
		*handle_out = ret.handle_out;



	/* Return the result */
	return ret.rc;
}



int PtlEQFree_internal(
	ptl_handle_eq_t	eventq_in
)
{
	PtlEQFree_internal_in		args;
	PtlEQFree_internal_out	ret;
	nal_t			*nal;

	if( !ptl_init ) {
		fprintf( stderr, "PtlEQFree_internal: Not initialized\n" );
		return PTL_NOINIT;
	}

	/*
	 * Copy arguments into the argument block to
	 * hand to the forwarding object
	 */
	args.eventq_in	= eventq_in;



	nal = ptl_interfaces[(eventq_in >> 16) & 0xF];
	if( !nal )
		return PTL_NOINIT;

	nal->forward(
		nal,
		PTL_EQFREE,
		&args,	sizeof(args),
		&ret,	sizeof(ret)
	);

	/*
	 * Copy the results into the return block
	 */



	/* Return the result */
	return ret.rc;
}



int PtlACEntry(
	ptl_handle_ni_t	ni_in,
	ptl_ac_index_t	index_in,
	ptl_process_id_t	match_id_in,
	ptl_pt_index_t	portal_in
)
{
	PtlACEntry_in		args;
	PtlACEntry_out	ret;
	nal_t			*nal;

	if( !ptl_init ) {
		fprintf( stderr, "PtlACEntry: Not initialized\n" );
		return PTL_NOINIT;
	}

	/*
	 * Copy arguments into the argument block to
	 * hand to the forwarding object
	 */
	args.ni_in	= ni_in;
	args.index_in	= index_in;
	args.match_id_in	= match_id_in;
	args.portal_in	= portal_in;



	nal = ptl_interfaces[(ni_in >> 16) & 0xF];
	if( !nal )
		return PTL_NOINIT;

	nal->forward(
		nal,
		PTL_ACENTRY,
		&args,	sizeof(args),
		&ret,	sizeof(ret)
	);

	/*
	 * Copy the results into the return block
	 */



	/* Return the result */
	return ret.rc;
}



int PtlPut(
	ptl_handle_md_t	md_in,
	ptl_ack_req_t	ack_req_in,
	ptl_process_id_t	target_in,
	ptl_pt_index_t	portal_in,
	ptl_ac_index_t	cookie_in,
	ptl_match_bits_t	match_bits_in,
	ptl_size_t	offset_in,
	ptl_hdr_data_t	hdr_data_in
)
{
	PtlPut_in		args;
	PtlPut_out	ret;
	nal_t			*nal;

	if( !ptl_init ) {
		fprintf( stderr, "PtlPut: Not initialized\n" );
		return PTL_NOINIT;
	}

	/*
	 * Copy arguments into the argument block to
	 * hand to the forwarding object
	 */
	args.md_in	= md_in;
	args.ack_req_in	= ack_req_in;
	args.target_in	= target_in;
	args.portal_in	= portal_in;
	args.cookie_in	= cookie_in;
	args.match_bits_in	= match_bits_in;
	args.offset_in	= offset_in;
	args.hdr_data_in	= hdr_data_in;



	nal = ptl_interfaces[(md_in >> 16) & 0xF];
	if( !nal )
		return PTL_NOINIT;

	nal->forward(
		nal,
		PTL_PUT,
		&args,	sizeof(args),
		&ret,	sizeof(ret)
	);

	/*
	 * Copy the results into the return block
	 */



	/* Return the result */
	return ret.rc;
}



int PtlGet(
	ptl_handle_md_t	md_in,
	ptl_process_id_t	target_in,
	ptl_pt_index_t	portal_in,
	ptl_ac_index_t	cookie_in,
	ptl_match_bits_t	match_bits_in,
	ptl_size_t	offset_in
)
{
	PtlGet_in		args;
	PtlGet_out	ret;
	nal_t			*nal;

	if( !ptl_init ) {
		fprintf( stderr, "PtlGet: Not initialized\n" );
		return PTL_NOINIT;
	}

	/*
	 * Copy arguments into the argument block to
	 * hand to the forwarding object
	 */
	args.md_in	= md_in;
	args.target_in	= target_in;
	args.portal_in	= portal_in;
	args.cookie_in	= cookie_in;
	args.match_bits_in	= match_bits_in;
	args.offset_in	= offset_in;



	nal = ptl_interfaces[(md_in >> 16) & 0xF];
	if( !nal )
		return PTL_NOINIT;

	nal->forward(
		nal,
		PTL_GET,
		&args,	sizeof(args),
		&ret,	sizeof(ret)
	);

	/*
	 * Copy the results into the return block
	 */



	/* Return the result */
	return ret.rc;
}


